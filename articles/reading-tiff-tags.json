{"slug":"reading-tiff-tags","metadata":{"title":"Reading Tiff Tags üè∑","pubdate":"2020-04-15","smallImage":"images/articles/reading-tiff-tags/tags.png","desc":"For my new tool, Geode, I needed to learn ALL about tiff tags. Turns out, there's a LOT of them...","keywords":"geode, tiff, code, geotiff, mapping, data, gis","date":"15th April 2020","timeToRead":6},"html":"<p class=\"mb-4\">I&#39;m currently in the process of adding several other formats to <a class=\"colorLink\" href=\"/projects/areo\">Areo</a>, my <em>&#39;take binary elevation data and make into exportable 3D mesh&#39;</em> tool, one of which is <a class=\"colorLink\" href=\"https://earthdata.nasa.gov/esdis/eso/standards-and-references/geotiff\" target=\"_blank\" rel=\"noopener noreferrer\">Geotiff</a>. Instead of just figuring out how to read the format (boo, boring, boo), I thought I&#39;d try and make an in-browser tool to read local tiff files, show 2D previews with custom colour mapping, and generate downloadable 3D mesh previews if applicable (hooray, 3D things, yay!) I also thought I&#39;d briefly write it all up as I went. üëã</p>\n<h2 id=\"incredibly-useful-sources-of-information\">Incredibly useful sources of information</h2>\n<ul>\n<li><a class=\"colorLink\" href=\"https://medium.com/planet-stories/reading-a-single-tiff-pixel-without-any-tiff-tools-fcbd43d8bd24\" target=\"_blank\" rel=\"noopener noreferrer\">This article</a> by Patrick Armstrong really quickly got me up to speed on exactly how the header information in a .tiff file is formatted. Patrick also delves into things like compression, that I&#39;ll definitely have to address down the line.</li>\n<li>Want to know what that random tiff tag ID is? Want to know all the possible values in its enum? Well Joris Van Damme from <a class=\"colorLink\" href=\"https://www.awaresystems.be/imaging/tiff/tifftags.html\" target=\"_blank\" rel=\"noopener noreferrer\">Aware Systems</a> has you covered! This site is basically a tiff tag bible. It was <strong>insanely</strong> useful.</li>\n<li>As was <a class=\"colorLink\" href=\"http://geotiff.maptools.org/spec/geotiff1.html\" target=\"_blank\" rel=\"noopener noreferrer\">Maptools.org</a>! <em>Many</em> of my Google searches brought me back to the fantastically curated information on this site.</li>\n<li>Paul Bourke&#39;s <a class=\"colorLink\" href=\"http://paulbourke.net/dataformats/tiff/tiff_summary.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">PDF Tiff Summary</a> was also <em>SUPER</em> useful in clarifying the different data types used in the format.</li>\n<li>Finally, I stumbled upon <a class=\"colorLink\" href=\"https://twitter.com/emilywselwood\" target=\"_blank\" rel=\"noopener noreferrer\">Emily Selwood</a>&#39;s fantastic <a class=\"colorLink\" href=\"https://github.com/emilyselwood/tiffhax\" target=\"_blank\" rel=\"noopener noreferrer\">Tiff Hax</a> tool as I was getting into the nitty gritty of IFD reading, and although I&#39;ve yet to delve into <a class=\"colorLink\" href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Go</a>, it was a fantastically useful sanity checker when it came to testing my own code!</li>\n</ul>\n<h2 id=\"breaking-down-the-format\">Breaking down the format</h2>\n<h3 id=\"byte-order--a-very-magic-number\">Byte Order &amp; A Very Magic Number</h3>\n<p class=\"mb-4\">At the start of <em>every</em> .tiff file there are 8 bytes of data. Something like :</p>\n<pre><code>4D4D002A 00000008</code></pre><p class=\"mb-4\">The first 2 bytes are either going to be both <em>4D</em> (i.e. <em>77</em> as a UInt8), or <em>49</em> (i.e. <em>73</em> as a UInt8). If it&#39;s <em>4D (77)</em> the <a class=\"colorLink\" href=\"https://www.geeksforgeeks.org/little-and-big-endian-mystery/\" target=\"_blank\" rel=\"noopener noreferrer\">byte order</a> of the file is BigEndian, if it&#39;s <em>49 (73)</em> byte order is LittleEndian. The example above is therefore BigEndian.</p>\n<p class=\"mb-4\">The 3rd or 4th byte (depending on your newly found byte order) is a <a class=\"colorLink\" href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)\" target=\"_blank\" rel=\"noopener noreferrer\">magic number</a>. Long story short, if it&#39;s not <strong>42</strong>, then this <em>isn&#39;t</em> a tiff file. Time to return/throw an error/walk away and grab lunch.</p>\n<p class=\"mb-4\">The 8th byte is a byte offset telling you where the first main section of header information begins. Which leads me nicely into...</p>\n<h3 id=\"ifds-subfiles-image-bands\">IFDs, subfiles, image bands...</h3>\n<p class=\"mb-4\">A single tiff file <em>can</em> hold multiple different (but more often than not, at least tangentially related) images within it. These <a class=\"colorLink\" href=\"https://en.wikipedia.org/wiki/TIFF#Multiple_subfiles\" target=\"_blank\" rel=\"noopener noreferrer\">subfiles</a> can be incredibly useful for storing lower resolution proxies of a main image, mask data, overlay information - essentially anything you want to bundle alongside the main image data.</p>\n<p class=\"mb-4\">Each one of these subfiles is described by an Image File Directory (IFD) - a section of header information containing <em>all</em> the metadata associated with that subfile. In theory. In practice, some of the tags on the first IFD are usually relevant to one or more of the subsequent IFDs, and as you delve deeper you might find other completely separate IFDs that contain <em>yet more</em> metadata relevant to the first IFD. Tiffs are nothing if not flexible.</p>\n<p class=\"mb-4\">If we follow the 8 byte offset we found above, we find ourselves at the start of our first IFD, which begins with these two bytes :</p>\n<pre><code>0010</code></pre><p class=\"mb-4\">This is our IFD field count, which after converting to UInt8 tells us that there are 16 fields we now need to find and parse.</p>\n<h3 id=\"fields-oh-so-many-fields\">Fields. Oh so many fields...</h3>\n<p class=\"mb-4\">IFD fields are always 12 bytes long, so let&#39;s grab the next 12 bytes and start parsing :</p>\n<pre><code>01000003 00000001 0C890000</code></pre><p class=\"mb-4\">The first 2 bytes give us the ID of the tiff tag. Converting <code>0100</code> to a short (AKA a 16-bit unsigned int) gives us a value of 256. One search of <a class=\"colorLink\" href=\"https://www.awaresystems.be/imaging/tiff/tifftags/search.html?q=256&amp;Submit=Find+Tags\" target=\"_blank\" rel=\"noopener noreferrer\">AwareSystems Tiff Tag Reference</a> later and :</p>\n<p class=\"mb-4\"><img src=\"images/articles/reading-tiff-tags/imageWidthTag.png\" alt=\"ImageWidth tag details\"></p>\n<p class=\"mb-4\">We&#39;ve found an <em>ImageWidth</em> tag! Let&#39;s move on and try to get the width itself.</p>\n<p class=\"mb-4\">The 3rd and 4th bytes give us the data type of this tag. Converting to a short, our <code>0003</code> gives a value of 3, meaning that the image width is also going to be a short.</p>\n<p class=\"mb-4\">The next 4 bytes give us the value count for the current field as a 32-bit unsigned int. In our case above, the <code>00000001</code> tells us that (logically) <em>ImageWidth</em> only has a single value. </p>\n<p class=\"mb-4\">The behaviour of the remaining 4 bytes differs slightly from field to field, depending on the data the field represents. For some fields with a single (often numerical) associated value, all of that value data can be found directly within the field bytes. However, in fields representing more complex values (such as arrays of information, longer strings etc.) the remaining bytes simply act as an offset to where that information is stored in the main body of the tiff file.</p>\n<p class=\"mb-4\">To determine whether the final bytes represent an offset, we can perform a simple calculation : </p>\n<pre><code>(# of values) * (# of bytes per value) &gt; (# of bytes remaining)</code></pre><p class=\"mb-4\">We know that we only have 4 bytes left from our original 12 bytes of field data, we&#39;ve already calculated our value count, and we know that the data type is <em>short</em> (i.e. 2 bytes per value). So in the case of our <em>ImageWidth</em> field, this calculation becomes :</p>\n<pre><code>isOffset = (1 * 2) &gt; 4</code></pre><p class=\"mb-4\">This evaluates to false in our <em>ImageWidth</em> case, meaning that the final 4 bytes represent the actual value of the field. These bytes are <code>0C890000</code>, which we can now convert to a value of <em>3209</em>. We&#39;ve found the width of our tiff file!</p>\n<p class=\"mb-4\">If <em>isOffset</em> had resolved to <em>true</em>, we&#39;d then have to perform a subsequent lookup into the tiff file, using the value of the final 4 bytes as our offset, and <code>(# of values) * (# of bytes per value)</code> as our byte count.</p>\n<h3 id=\"the-next-ifd\">The next IFD...</h3>\n<p class=\"mb-4\">16 fields of 12 bytes later, there are 8 more useful bytes that make up this current IFD. Converted to a long (i.e. 4 byte, 32-bit unsigned int) these bytes give you the byte offset to the next IFD contained within the tiff file. </p>\n<p class=\"mb-4\">If this byte offset is &gt; 0, you&#39;ll need to loop around and repeat all of your field parsing on this new IFD. If this is the final IFD in the file, the byte offset will be 0, and you can now relatively comfortably stop processing IFDs. Hooray!</p>\n<h2 id=\"so-far-so-good\">So far, so good</h2>\n<p class=\"mb-4\">So ends this first, pretty dry article about Geode! Fun, eh? üò¨ I&#39;m hoping that the above might prove vaguely useful to anyone thinking about attempting something similar. And if not, it will at least remind me how I approached it, when I no-doubt find myself doing this again in a year or so!</p>\n<p class=\"mb-4\">If you head over to <a class=\"colorLink\" href=\"https://mattbrealey.com/geode\" target=\"_blank\" rel=\"noopener noreferrer\">the app</a> right now, you&#39;ll be able to see the above in practice, as you can load any tiff file and browse of the available tag information for each IFD found.</p>\n<p class=\"mb-4\">Next step, pixel loading!</p>\n","prev":{"slug":"hello-motivation","title":"Hello Motivation"},"next":null}